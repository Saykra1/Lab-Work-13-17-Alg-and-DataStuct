# Lab-Work-13-17-Alg-and-DataStuct

# ЛАБОРАТОРНАЯ РАБОТА № 13-17
## Изучение и реализация алгоритмов в различных предметных областях

**Выполнил:** Князев Макар  
**Группа:** ПИ04
**Дата:** 19 декабря 2025 г.  

---

## Содержание
1. Автоматы и регулярные выражения (DFA/NFA/Regex)
2. Внешняя сортировка (External Merge Sort)
3. Выпуклая оболочка (Convex Hull, алгоритм Грэхема)
4. Максимальный поток (Max Flow, Ford–Fulkerson)

---

# Алгоритм 1: Автоматы и регулярные выражения (DFA/NFA/Regex)

## 1.1 Краткое описание области определения алгоритма

Детерминированные конечные автоматы (DFA), недетерминированные конечные автоматы (NFA) и регулярные выражения — это фундаментальные инструменты теории формальных языков и компиляции. Они используются для распознавания строк, принадлежащих к определённому языку.

**DFA (Deterministic Finite Automaton)** — это математическая модель, которая принимает на вход символ за символом и переходит между состояниями строго по одному пути. Каждый переход определён однозначно функцией переходов δ(q, a).

**NFA (Nondeterministic Finite Automaton)** расширяет DFA, допуская несколько возможных переходов из одного состояния при получении одного символа, а также ε-переходы (переходы без ввода символов).

**Регулярные выражения** — это компактная текстовая нотация для описания языков. Они широко применяются в текстовых редакторах, компиляторах, поиске и замене текста.

### Применение на практике:
- Компиляторы: распознавание лексем (токенов);
- Текстовые редакторы: поиск и замена по шаблону;
- Валидация данных: проверка формата e-mail, номера телефона и т.д.;
- Сетевые фильтры: анализ сетевых пакетов.

### Входные и выходные данные:
- **Вход:** Строка символов и описание автомата (множество состояний, алфавит, функция переходов, стартовое состояние, множество принимающих состояний).
- **Выход:** Булево значение — принимается ли строка (True/False).

---

## 1.2 Блок-схема алгоритма работы DFA

```
    ┌─────────────────────────────────┐
    │      НАЧАЛО                     │
    └────────────┬────────────────────┘
                 │
    ┌────────────▼────────────────────┐
    │  Получить строку s и описание   │
    │  автомата (δ, q0, F)            │
    └────────────┬────────────────────┘
                 │
    ┌────────────▼────────────────────┐
    │  current_state ← q0             │
    │  index ← 0                      │
    └────────────┬────────────────────┘
                 │
    ┌────────────▼────────────────────┐
    │ S1: index < |s| ?               │─── НЕТ ──┐
    └────┬───────────────────────────┘          │
         │ДА                                     │
    ┌────▼────────────────────────────┐        │
    │ S2: char ← s[index]             │        │
    └────┬───────────────────────────┘        │
         │                                    │
    ┌────▼────────────────────────────┐      │
    │ S3: char ∈ alphabet ?           │──НЕТ─┐
    └────┬───────────────────────────┘      │ │
         │ДА                                │ │
    ┌────▼────────────────────────────┐    │ │
    │ S4: current_state ←             │    │ │
    │     δ(current_state, char)      │    │ │
    └────┬───────────────────────────┘    │ │
         │                                │ │
    ┌────▼────────────────────────────┐  │ │
    │ S5: index ← index + 1           │  │ │
    │ (вернуться к S1)                │  │ │
    └────┬───────────────────────────┘  │ │
         │                              │ │
         └──────────────────────────────┘ │
                                          │
    ┌─────────────────────────────────────┘
    │
    ┌────▼────────────────────────────┐
    │ S6: current_state ∈ F ?         │
    └────┬─────────────┬──────────────┘
         │ДА          │НЕТ
    ┌────▼─────────┐  ┌─▼──────────┐
    │ Вернуть TRUE │  │Вернуть FALSE│
    └─────┬────────┘  └─┬──────────┘
          │             │
    ┌─────▼─────────────▼────────────┐
    │        КОНЕЦ                   │
    └────────────────────────────────┘
```

---

## 1.3 Пошаговый анализ работы алгоритма

### Пример: DFA для языка строк, заканчивающихся на "ab"

**Входные данные:**
- Алфавит: {a, b}
- Состояния: {q0, q1, q2}
- Начальное состояние: q0
- Принимающие состояния: {q2}
- Функция переходов:
  - δ(q0, a) = q1, δ(q0, b) = q0
  - δ(q1, a) = q1, δ(q1, b) = q2
  - δ(q2, a) = q1, δ(q2, b) = q0

**Анализ строки "aab":**

| Шаг | Текущее состояние | Текущий символ | Действие | Новое состояние |
|-----|-------------------|----------------|---------|-----------------|
| S1  | q0                | 'a'            | δ(q0, a) = q1 | q1 |
| S2  | q1                | 'a'            | δ(q1, a) = q1 | q1 |
| S3  | q1                | 'b'            | δ(q1, b) = q2 | q2 |
| S4  | q2                | —              | q2 ∈ {q2} → принять | **TRUE** |

**Анализ строки "aba":**

| Шаг | Текущее состояние | Текущий символ | Действие | Новое состояние |
|-----|-------------------|----------------|---------|-----------------|
| S1  | q0                | 'a'            | δ(q0, a) = q1 | q1 |
| S2  | q1                | 'b'            | δ(q1, b) = q2 | q2 |
| S3  | q2                | 'a'            | δ(q2, a) = q1 | q1 |
| S4  | q1                | —              | q1 ∉ {q2} → отклонить | **FALSE** |

---

## 1.4 Программный код алгоритма

```python
from typing import Dict, Set, Tuple, Optional


class DFA:
    """
    Класс для реализации детерминированного конечного автомата.
    
    Атрибуты:
        states: множество всех состояний
        alphabet: алфавит (множество допустимых символов)
        transition: словарь функции переходов (state, char) → next_state
        start_state: начальное состояние
        accept_states: множество принимающих состояний
    """
    def __init__(
        self,
        states: Set[str],
        alphabet: Set[str],
        transition: Dict[Tuple[str, str], str],
        start_state: str,
        accept_states: Set[str],
    ):
        self.states = states
        self.alphabet = alphabet
        self.transition = transition
        self.start_state = start_state
        self.accept_states = accept_states

    def accepts(self, s: str) -> bool:
        """
        Проверка, принимает ли DFA строку s.
        
        Args:
            s: входная строка
            
        Returns:
            True, если строка принимается, иначе False
        """
        current = self.start_state
        
        # S1-S5: Проходим по каждому символу
        for ch in s:
            # Проверяем, принадлежит ли символ алфавиту
            if ch not in self.alphabet:
                return False
            
            # S4: Выполняем переход
            current = self.transition.get((current, ch))
            
            # Если переход не определён, строка отклоняется
            if current is None:
                return False
        
        # S6: Проверяем, достигли ли мы принимающего состояния
        return current in self.accept_states


class SimpleNFA:
    """
    Класс для реализации недетерминированного конечного автомата.
    Поддерживает ε-переходы (epsilon-переходы).
    """
    def __init__(self):
        self.states: Set[int] = set()
        self.start_state: Optional[int] = None
        self.accept_states: Set[int] = set()
        # transitions[state][symbol] = set(next_states)
        self.transitions: Dict[int, Dict[Optional[str], Set[int]]] = {}

    def add_state(self, state: int, is_start=False, is_accept=False):
        """Добавить состояние в автомат."""
        self.states.add(state)
        if is_start:
            self.start_state = state
        if is_accept:
            self.accept_states.add(state)
        if state not in self.transitions:
            self.transitions[state] = {}

    def add_transition(self, from_state: int, symbol: Optional[str], to_state: int):
        """Добавить переход (symbol=None означает ε-переход)."""
        if from_state not in self.transitions:
            self.transitions[from_state] = {}
        if symbol not in self.transitions[from_state]:
            self.transitions[from_state][symbol] = set()
        self.transitions[from_state][symbol].add(to_state)

    def _epsilon_closure(self, states: Set[int]) -> Set[int]:
        """Вычислить ε-замыкание множества состояний."""
        stack = list(states)
        closure = set(states)
        
        while stack:
            state = stack.pop()
            # Ищем все ε-переходы из текущего состояния
            for nxt in self.transitions.get(state, {}).get(None, set()):
                if nxt not in closure:
                    closuare.add(nxt)
                    stack.append(nxt)
        
        return closure

    def accepts(self, s: str) -> bool:
        """
        Проверка, принимает ли NFA строку s.
        
        Args:
            s: входная строка
            
        Returns:
            True, если строка принимается, иначе False
        """
        if self.start_state is None:
            return False
        
        # Начинаем с ε-замыкания начального состояния
        current_states = self._epsilon_closure({self.start_state})
        
        # Проходим по каждому символу входной строки
        for ch in s:
            next_states = set()
            
            # Для каждого текущего состояния вычисляем переходы
            for st in current_states:
                for nxt in self.transitions.get(st, {}).get(ch, set()):
                    next_states.add(nxt)
            
            # Вычисляем ε-замыкание новых состояний
            current_states = self._epsilon_closure(next_states)
            
            # Если нет текущих состояний, строка отклоняется
            if not current_states:
                return False
        
        # Проверяем, есть ли хотя бы одно принимающее состояние
        return any(st in self.accept_states for st in current_states)


import re


def regex_match(pattern: str, s: str) -> bool:
    """
    Проверка строки s на соответствие регулярному выражению pattern.
    
    Args:
        pattern: регулярное выражение
        s: входная строка
        
    Returns:
        True, если строка соответствует шаблону, иначе False
    """
    return re.fullmatch(pattern, s) is not None


# ===== ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ =====

# Пример 1: DFA для языка строк, заканчивающихся на "ab"
states = {"q0", "q1", "q2"}
alphabet = {"a", "b"}
transition = {
    ("q0", "a"): "q1",
    ("q0", "b"): "q0",
    ("q1", "a"): "q1",
    ("q1", "b"): "q2",
    ("q2", "a"): "q1",
    ("q2", "b"): "q0",
}
start_state = "q0"
accept_states = {"q2"}

dfa = DFA(states, alphabet, transition, start_state, accept_states)

print("=== DFA Тесты ===")
print(f"dfa.accepts('ab')    = {dfa.accepts('ab')}")       # True
print(f"dfa.accepts('aab')   = {dfa.accepts('aab')}")      # True
print(f"dfa.accepts('aba')   = {dfa.accepts('aba')}")      # False
print(f"dfa.accepts('bbbab') = {dfa.accepts('bbbab')}")    # True


# Пример 2: NFA с ε-переходами
nfa = SimpleNFA()
nfa.add_state(0, is_start=True)
nfa.add_state(1)
nfa.add_state(2, is_accept=True)

nfa.add_transition(0, "a", 1)
nfa.add_transition(1, "b", 2)
nfa.add_transition(0, "b", 0)
nfa.add_transition(1, "a", 1)
nfa.add_transition(2, "a", 2)
nfa.add_transition(2, "b", 2)

print("\n=== NFA Тесты ===")
print(f"nfa.accepts('ab')    = {nfa.accepts('ab')}")       # True
print(f"nfa.accepts('aab')   = {nfa.accepts('aab')}")      # True
print(f"nfa.accepts('ba')    = {nfa.accepts('ba')}")       # False


# Пример 3: Регулярные выражения
email_pattern = r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}"

print("\n=== Regex Тесты ===")
print(f"regex_match(email_pattern, 'example@example.com') = {regex_match(email_pattern, 'example@example.com')}")  # True
print(f"regex_match(email_pattern, 'bad-email') = {regex_match(email_pattern, 'bad-email')}")  # False
```

---

## 1.5 Оценка временной сложности алгоритма

### Временная сложность: O(|s|)

где |s| — длина входной строки.

### Обоснование:

1. **Основной цикл (строки 1-5 блок-схемы):** Цикл выполняется ровно столько раз, сколько символов в строке s. То есть n итераций, где n = |s|.

2. **Внутри цикла:** 
   - Проверка принадлежности символа алфавиту: O(1) (если использовать set, lookup — O(1) в среднем)
   - Поиск функции перехода δ(q, ch) в словаре: O(1) в среднем

3. **Финальная проверка:** Проверка принадлежности состояния множеству принимающих состояний: O(1).

4. **Итого:** O(n) + O(1) + O(1) = **O(n)**, где n = |s|.

### Пространственная сложность: O(|Q| + |Σ|)

где |Q| — количество состояний, |Σ| — размер алфавита. Это объём памяти, необходимый для хранения описания автомата.

### Примечание:
Данный алгоритм исключительно эффективен, так как требует только одного прохода по входной строке. Это делает конечные автоматы идеальным выбором для задач лексического анализа в компиляторах и поиска по шаблону в больших текстовых файлах.

---

# Алгоритм 2: Внешняя сортировка (External Merge Sort)

## 2.1 Краткое описание области определения алгоритма

Внешняя сортировка — это алгоритм сортировки больших массивов данных, которые не помещаются в оперативную память компьютера. Вместо этого данные хранятся во внешней памяти (обычно на диске) и обрабатываются блоками.

**Основная идея:** Разделить данные на куски, каждый из которых умещается в памяти, отсортировать каждый кусок отдельно, а затем слить всё кучи отсортированных кусков в один отсортированный файл.

### Применение на практике:
- Сортировка больших баз данных, которые не помещаются в ОЗУ;
- Обработка логов миллиардов строк;
- Внешние базы данных (вроде MySQL, PostgreSQL) используют модификации этого алгоритма;
- MapReduce и другие системы обработки больших данных (Big Data).

### Входные и выходные данные:
- **Вход:** Файл с неупорядоченными данными (строки или числа), размер оперативной памяти, доступной для сортировки одного блока.
- **Выход:** Файл с отсортированными данными в том же формате.

---

## 2.2 Блок-схема алгоритма работы External Merge Sort

```
    ┌──────────────────────────────────┐
    │      НАЧАЛО                      │
    └────────────┬─────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  Получить входной файл,           │
    │  chunk_size (размер блока в памяти)
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S1: temp_files ← [ ]             │
    │  file_counter ← 0                 │
    │  chunk ← [ ]                      │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S2: Открыть входной файл         │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │ S3: Есть ещё строки ?             │─── НЕТ ──┐
    └────┬───────────────────────────┘          │
         │ДА                                     │
    ┌────▼──────────────────────────────┐      │
    │ S4: line ← readline()             │      │
    │ chunk.append(line)                │      │
    └────┬──────────────────────────────┘      │
         │                                    │
    ┌────▼──────────────────────────────┐     │
    │ S5: len(chunk) >= chunk_size ?    │─НЕТ─┼──┐
    │                                   │    │  │
    └────┬────────────────────────────┘    │  │
         │ДА                              │  │
    ┌────▼──────────────────────────────┐ │  │
    │ S6: Отсортировать chunk           │ │  │
    │ chunk.sort()                      │ │  │
    └────┬──────────────────────────────┘ │  │
         │                                │  │
    ┌────▼──────────────────────────────┐ │  │
    │ S7: Записать chunk в temp файл    │ │  │
    │ temp_files.append(имя файла)      │ │  │
    │ chunk ← [ ]                       │ │  │
    │ file_counter++                    │ │  │
    │ (вернуться к S3)                  │ │  │
    └────┬──────────────────────────────┘ │  │
         │                                │  │
         └────────────────────────────────┘  │
                                             │
    ┌────────────────────────────────────────┘
    │
    ┌────▼──────────────────────────────┐
    │ S8: len(chunk) > 0 ?              │─── НЕТ ──┐
    └────┬───────────────────────────┘         │
         │ДА                                    │
    ┌────▼──────────────────────────────┐      │
    │ S9: Отсортировать и записать      │      │
    │ последний chunk                   │      │
    │ temp_files.append(имя файла)      │      │
    └────┬──────────────────────────────┘      │
         │                                     │
         └──────────────────────────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S10: temp_files ← массив temp     │
    │ файлов (отсортированные блоки)   │
    └───────────────┬──────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S11: Открыть все temp файлы      │
    │ Инициализировать min-heap        │
    └───────────────┬──────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S12: В heap добавить первую      │
    │ строку из каждого temp файла     │
    └───────────────┬──────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S13: heap не пуста ?             │─── НЕТ ──┐
    └────┬──────────────────────────┘         │
         │ДА                                   │
    ┌────▼──────────────────────────────┐    │
    │ S14: value ← heap.pop_min()       │    │
    │ Записать value в выходной файл   │    │
    └────┬──────────────────────────────┘    │
         │                                   │
    ┌────▼──────────────────────────────┐   │
    │ S15: Читать следующую строку из  │   │
    │ соответствующего temp файла      │   │
    │ Добавить её в heap               │   │
    │ (вернуться к S13)                │   │
    └────┬──────────────────────────────┘   │
         │                                  │
         └──────────────────────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S16: Закрыть все файлы           │
    │ Удалить временные файлы          │
    └───────────────┬──────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │        КОНЕЦ                     │
    │  Результат в выходном файле      │
    └────────────────────────────────────┘
```

---

## 2.3 Пошаговый анализ работы алгоритма

### Пример: сортировка файла с 12 строками (chunk_size = 4)

**Входной файл:** 
```
banana
apple
cherry
date
elderberry
fig
grape
honeydew
iris
jackfruit
kiwi
lemon
```

### Фаза 1: Разбиение на блоки и их сортировка (S1-S9)

| Блок | Исходные строки | После сортировки | Временный файл |
|------|-----------------|-----------------|----------------|
| 1    | banana, apple, cherry, date | apple, banana, cherry, date | temp_0.txt |
| 2    | elderberry, fig, grape, honeydew | elderberry, fig, grape, honeydew | temp_1.txt |
| 3    | iris, jackfruit, kiwi, lemon | iris, jackfruit, kiwi, lemon | temp_2.txt |

### Фаза 2: Многопутевое слияние (S10-S15)

**Шаг 1:** Инициализация min-heap первыми строками каждого файла:
```
heap = [("apple", 0), ("elderberry", 1), ("iris", 2)]
```

**Шаг 2-12:** Итеративное слияние:

| Итерация | Выбрано из heap | Записано в выход | Добавлено в heap |
|----------|-----------------|------------------|------------------|
| 1        | ("apple", 0)    | apple            | ("banana", 0)    |
| 2        | ("banana", 0)   | banana           | ("cherry", 0)    |
| 3        | ("cherry", 0)   | cherry           | ("date", 0)      |
| 4        | ("date", 0)     | date             | —                |
| 5        | ("elderberry", 1) | elderberry     | ("fig", 1)       |
| 6        | ("fig", 1)      | fig              | ("grape", 1)     |
| 7        | ("grape", 1)    | grape            | ("honeydew", 1)  |
| 8        | ("honeydew", 1) | honeydew         | —                |
| 9        | ("iris", 2)     | iris             | ("jackfruit", 2) |
| 10       | ("jackfruit", 2)| jackfruit        | ("kiwi", 2)      |
| 11       | ("kiwi", 2)     | kiwi             | ("lemon", 2)     |
| 12       | ("lemon", 2)    | lemon            | —                |

**Выходной файл (отсортированный):**
```
apple
banana
cherry
date
elderberry
fig
grape
honeydew
iris
jackfruit
kiwi
lemon
```

---

## 2.4 Программный код алгоритма

```python
import os
import heapq
from typing import List


class ExternalMergeSort:
    """
    Класс для сортировки больших файлов, которые не помещаются в ОЗУ.
    
    Атрибуты:
        chunk_size: максимальное количество строк в одном куске,
                   загружаемом в память
    """
    def __init__(self, chunk_size: int = 100_000):
        """
        Инициализация сортировщика.
        
        Args:
            chunk_size: размер одного блока (в строках)
        """
        self.chunk_size = chunk_size

    def _create_sorted_chunks(self, input_file: str) -> List[str]:
        """
        Фаза 1: Чтение входного файла, разбиение на куски 
        и сортировка каждого куска.
        
        Args:
            input_file: путь к входному файлу
            
        Returns:
            Список имён временных файлов с отсортированными кусками
        """
        temp_files = []
        chunk = []
        file_counter = 0

        # S1-S9: Читаем файл и разбиваем на куски
        with open(input_file, "r", encoding="utf-8") as f:
            for line in f:
                chunk.append(line.rstrip("\n"))
                
                # S5: Если кусок заполнен, сортируем и сохраняем его
                if len(chunk) >= self.chunk_size:
                    chunk.sort()  # S6
                    
                    # S7: Записываем в временный файл
                    temp_name = f"temp_{file_counter}.txt"
                    with open(temp_name, "w", encoding="utf-8") as tf:
                        for item in chunk:
                            tf.write(item + "\n")
                    temp_files.append(temp_name)
                    chunk = []
                    file_counter += 1

        # S8-S9: Обработка последнего неполного куска (если он есть)
        if chunk:
            chunk.sort()
            temp_name = f"temp_{file_counter}.txt"
            with open(temp_name, "w", encoding="utf-8") as tf:
                for item in chunk:
                    tf.write(item + "\n")
            temp_files.append(temp_name)

        return temp_files

    def _merge_chunks(self, temp_files: List[str], output_file: str) -> None:
        """
        Фаза 2: Многопутевое слияние отсортированных кусков в один файл.
        
        Args:
            temp_files: список имён временных файлов
            output_file: путь к выходному файлу
        """
        # S11: Открываем все временные файлы
        files = [open(name, "r", encoding="utf-8") for name in temp_files]
        
        # S12: Инициализируем min-heap (куча)
        # Каждый элемент: (значение, индекс файла)
        heap = []

        # S12: Добавляем первую строку из каждого файла
        for i, f in enumerate(files):
            line = f.readline()
            if line:
                heapq.heappush(heap, (line.rstrip("\n"), i))

        # S13-S15: Основной цикл многопутевого слияния
        with open(output_file, "w", encoding="utf-8") as out:
            while heap:
                # S14: Извлекаем минимальную строку
                value, idx = heapq.heappop(heap)
                out.write(value + "\n")

                # S15: Читаем следующую строку из того же файла
                next_line = files[idx].readline()
                if next_line:
                    heapq.heappush(heap, (next_line.rstrip("\n"), idx))

        # S16: Закрываем файлы и удаляем временные файлы
        for f in files:
            f.close()
        for name in temp_files:
            os.remove(name)

    def sort_file(self, input_file: str, output_file: str) -> None:
        """
        Полный процесс сортировки большого файла.
        
        Args:
            input_file: путь к входному файлу
            output_file: путь к выходному файлу
        """
        print(f"Начало сортировки файла: {input_file}")
        
        # Фаза 1: Разбиение и сортировка кусков
        print("Фаза 1: Разбиение на куски и их сортировка...")
        temp_files = self._create_sorted_chunks(input_file)
        print(f"Создано {len(temp_files)} отсортированных кусков")
        
        # Фаза 2: Слияние кусков
        print("Фаза 2: Слияние отсортированных кусков...")
        self._merge_chunks(temp_files, output_file)
        
        print(f"Сортировка завершена. Результат в {output_file}")


# ===== ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ =====

if __name__ == "__main__":
    # Создание тестового файла с неупорядоченными данными
    test_data = [
        "banana",
        "apple",
        "cherry",
        "date",
        "elderberry",
        "fig",
        "grape",
        "honeydew",
        "iris",
        "jackfruit",
        "kiwi",
        "lemon",
    ]
    
    input_filename = "test_input.txt"
    output_filename = "test_sorted.txt"
    
    # Создаём входной файл
    with open(input_filename, "w") as f:
        for item in test_data:
            f.write(item + "\n")
    
    print(f"Создан тестовый файл: {input_filename}")
    print(f"Исходные данные: {test_data}\n")
    
    # Выполняем внешнюю сортировку (chunk_size=4 для наглядности)
    sorter = ExternalMergeSort(chunk_size=4)
    sorter.sort_file(input_filename, output_filename)
    
    # Читаем отсортированный результат
    print(f"\nОтсортированные данные из {output_filename}:")
    with open(output_filename, "r") as f:
        sorted_data = [line.rstrip("\n") for line in f]
        for item in sorted_data:
            print(f"  {item}")
    
    # Очистка (удаляем тестовые файлы)
    if os.path.exists(input_filename):
        os.remove(input_filename)
    if os.path.exists(output_filename):
        os.remove(output_filename)
    
    print("\nТестовые файлы удалены.")
```

---

## 2.5 Оценка временной сложности алгоритма

### Временная сложность: O(n log n)

где n — общее количество элементов (строк) во входном файле.

### Обоснование:

**Фаза 1: Разбиение на куски и их сортировка**
- Количество кусков: k = ⌈n / chunk_size⌉
- Сортировка одного куска размера m: O(m log m)
- Общее время фазы 1: k · O(m log m) = O(n log m), где m = chunk_size

**Фаза 2: Многопутевое слияние**
- Количество фаз слияния: O(log k) = O(log(n/m))
- На каждой фазе обрабатываются все n элементов: O(n)
- Каждая операция с heap (push/pop): O(log k)
- Общее время фазы 2: O(n log k) = O(n log(n/m))

**Итого:**
O(n log m) + O(n log(n/m)) = O(n log m + n log n - n log m) = **O(n log n)**

### Пространственная сложность: O(m + k)

где m = chunk_size (размер одного куска в памяти), k — количество кусков. На практике это O(m), так как m фиксирован и не зависит от общего размера файла.

### Примечание:
Данный алгоритм позволяет сортировать файлы размером в терабайты, используя всего несколько гигабайт памяти. Это критически важно для работы с Big Data.

---

# Алгоритм 3: Выпуклая оболочка (Convex Hull, алгоритм Грэхема)

## 3.1 Краткое описание области определения алгоритма

Выпуклая оболочка (convex hull) — это минимальный выпуклый многоугольник, который содержит все данные точки на плоскости. Другими словами, это "упругая лента", натянутая вокруг крайних точек множества.

**Алгоритм Грэхема** — один из самых быстрых способов построить выпуклую оболочку. Он работает за время O(n log n) благодаря сортировке.

### Применение на практике:
- Компьютерная графика: определение видимых объектов, вычисление пересечений;
- Геоинформационные системы (ГИС): анализ пространственных данных;
- Робототехника: планирование траектории движения;
- Вычислительная геометрия: основа для других геометрических алгоритмов;
- Обработка изображений: контурный анализ.

### Входные и выходные данные:
- **Вход:** Множество точек на плоскости (координаты (x, y)).
- **Выход:** Упорядоченный список точек, образующих выпуклую оболочку (обычно в порядке обхода против часовой стрелки).

---

## 3.2 Блок-схема алгоритма работы Graham Scan

```
    ┌─────────────────────────────────┐
    │      НАЧАЛО                     │
    └────────────┬─────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  Получить множество точек P      │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S1: n ← |P| (количество точек)   │
    │  Если n ≤ 1, вернуть P            │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S2: Найти точку p0 с           │
    │  минимальной y-координатой       │
    │  (и минимальной x при равенстве) │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S3: Обменять p0 и первый        │
    │  элемент списка (p0 на место 0)  │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S4: Отсортировать остальные     │
    │  точки (P[1]..P[n-1]) по         │
    │  полярному углу относительно p0  │
    │  (угол от горизонтали до вектора │
    │  p0→p)                           │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S5: hull ← [] (пустой стек)      │
    │  hull.push(p0)                    │
    │  hull.push(P[1])                  │
    │  hull.push(P[2])                  │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S6: i ← 3                        │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │ S7: i < n ?                       │─── НЕТ ──┐
    └────┬───────────────────────────┘         │
         │ДА                                   │
    ┌────▼──────────────────────────────┐    │
    │ S8: Пока |hull| ≥ 2 и            │    │
    │ поворот(hull[-2], hull[-1], P[i])│    │
    │ ≠ "влево":                        │    │
    │ hull.pop()                        │    │
    │ (удаляем точку, если она         │    │
    │ создает правый поворот)          │    │
    └────┬──────────────────────────────┘   │
         │                                  │
    ┌────▼──────────────────────────────┐  │
    │ S9: hull.push(P[i])               │  │
    │ i ← i + 1                         │  │
    │ (вернуться к S7)                  │  │
    └────┬──────────────────────────────┘  │
         │                                 │
         └─────────────────────────────────┘
                      │
    ┌─────────────────▼──────────────────┐
    │ S10: Вернуть hull (выпуклая       │
    │ оболочка как список точек)       │
    └─────────────────┬──────────────────┘
                      │
    ┌─────────────────▼──────────────────┐
    │        КОНЕЦ                      │
    └────────────────────────────────────┘
```

---

## 3.3 Пошаговый анализ работы алгоритма

### Пример: построение выпуклой оболочки для 8 точек

**Входные точки:**
```
(0, 3), (1, 1), (2, 2), (4, 4), (0, 0), (1, 2), (3, 1), (3, 3)
```

### Шаг S1-S3: Поиск опорной точки

| Точка | x | y | Минимальна? |
|-------|---|---|-------------|
| (0, 0) | 0 | 0 | **Да** |
| (0, 3) | 0 | 3 | Нет |
| (1, 1) | 1 | 1 | Нет |
| (1, 2) | 1 | 2 | Нет |
| (2, 2) | 2 | 2 | Нет |
| (3, 1) | 3 | 1 | Нет |
| (3, 3) | 3 | 3 | Нет |
| (4, 4) | 4 | 4 | Нет |

**Опорная точка p0 = (0, 0)**

### Шаг S4: Сортировка по полярному углу

После перемещения p0 на первое место, остальные точки сортируются по углу atan2(y-0, x-0):

| Точка | Угол (градусы) | Расстояние от p0 |
|-------|---|---|
| (1, 1) | 45° | 1.41 |
| (3, 1) | 18.4° | 3.16 |
| (1, 2) | 63.4° | 2.24 |
| (2, 2) | 45° | 2.83 |
| (3, 3) | 45° | 4.24 |
| (4, 4) | 45° | 5.66 |
| (0, 3) | 90° | 3 |

**Отсортированный порядок (из расчета расстояния при равных углах):**
```
(0, 0), (3, 1), (1, 1), (2, 2), (3, 3), (4, 4), (0, 3)
```

### Шаг S5-S9: Построение оболочки (обход точек)

| Итерация | hull | Текущая точка | Проверка | Действие | Новый hull |
|----------|------|---------------|----------|---------|------------|
| Инит | [(0,0), (3,1), (1,1)] | — | — | — | [(0,0), (3,1), (1,1)] |
| 1 | [(0,0), (3,1), (1,1)] | (2,2) | Влево? | Да → добавить | [(0,0), (3,1), (1,1), (2,2)] |
| 2 | [(0,0), (3,1), (1,1), (2,2)] | (3,3) | Влево? | Да → добавить | [(0,0), (3,1), (1,1), (2,2), (3,3)] |
| 3 | [(0,0), (3,1), (1,1), (2,2), (3,3)] | (4,4) | Влево? | Да → добавить | [(0,0), (3,1), (1,1), (2,2), (3,3), (4,4)] |
| 4 | [(0,0), (3,1), (1,1), (2,2), (3,3), (4,4)] | (0,3) | Влево? | Нет → удалить (4,4) | [(0,0), (3,1), (1,1), (2,2), (3,3)] |
| | | | | Нет → удалить (3,3) | [(0,0), (3,1), (1,1), (2,2)] |
| | | | | Нет → удалить (2,2) | [(0,0), (3,1), (1,1)] |
| | | | | Нет → удалить (1,1) | [(0,0), (3,1)] |
| | | | | Влево → добавить (0,3) | [(0,0), (3,1), (0,3)] |

**Результат: Выпуклая оболочка**
```
(0, 0), (3, 1), (4, 4), (0, 3)
```

---

## 3.4 Программный код алгоритма

```python
from typing import List, Tuple
import math


Point = Tuple[float, float]


def orientation(p: Point, q: Point, r: Point) -> int:
    """
    Определить ориентацию упорядоченной тройки точек (p, q, r).
    
    Args:
        p, q, r: три точки
        
    Returns:
        0 — точки коллинеарны (лежат на одной линии)
        1 — поворот по часовой стрелке (clockwise)
        2 — поворот против часовой стрелки (counterclockwise)
    
    Использует кросс-произведение для определения направления поворота:
    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
    """
    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
    
    if abs(val) < 1e-9:  # близко к нулю
        return 0  # коллинеарны
    
    return 1 if val > 0 else 2  # 1 = clockwise, 2 = counterclockwise


def polar_angle(p0: Point, p: Point) -> float:
    """
    Вычислить полярный угол точки p относительно опорной точки p0.
    
    Args:
        p0: опорная точка
        p: точка, для которой вычисляется угол
        
    Returns:
        Угол в радианах (в диапазоне -π до π)
    """
    return math.atan2(p[1] - p0[1], p[0] - p0[0])


def distance_squared(p0: Point, p: Point) -> float:
    """Вычислить квадрат расстояния между двумя точками."""
    return (p[0] - p0[0]) ** 2 + (p[1] - p0[1]) ** 2


def graham_scan(points: List[Point]) -> List[Point]:
    """
    Построить выпуклую оболочку множества точек методом Грэхема.
    
    Args:
        points: список точек (x, y)
        
    Returns:
        Список точек выпуклой оболочки в порядке обхода против часовой стрелки
        
    Временная сложность: O(n log n) из-за сортировки
    Пространственная сложность: O(n)
    """
    n = len(points)
    
    # S1: Обработка граничных случаев
    if n <= 2:
        return points[:]
    
    # S2: Находим точку с минимальной y-координатой (опорная точка p0)
    # При равенстве y выбираем точку с минимальной x
    min_idx = 0
    for i in range(1, n):
        if (points[i][1] < points[min_idx][1]) or (
            points[i][1] == points[min_idx][1] and points[i][0] < points[min_idx][0]
        ):
            min_idx = i
    
    p0 = points[min_idx]
    
    # S3: Переместим p0 в начало списка (обмен)
    points = [p0] + [points[i] for i in range(n) if i != min_idx]
    
    # S4: Сортируем остальные точки по полярному углу
    # При равных углах сортируем по расстоянию от p0
    sorted_points = points[1:]
    sorted_points.sort(
        key=lambda p: (polar_angle(p0, p), distance_squared(p0, p))
    )
    
    # S5: Инициализируем стек (выпуклую оболочку) первыми тремя точками
    hull = [p0, sorted_points[0], sorted_points[1]]
    
    # S6-S9: Проходим по остальным точкам
    for i in range(2, len(sorted_points)):
        p = sorted_points[i]
        
        # S8: Удаляем точки, которые создают правый поворот
        while len(hull) >= 2 and orientation(hull[-2], hull[-1], p) != 2:
            hull.pop()
        
        # S9: Добавляем текущую точку
        hull.append(p)
    
    # S10: Возвращаем выпуклую оболочку
    return hull


# ===== ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ =====

if __name__ == "__main__":
    # Пример 1: Simple случай
    pts1 = [
        (0, 3),
        (1, 1),
        (2, 2),
        (4, 4),
        (0, 0),
        (1, 2),
        (3, 1),
        (3, 3),
    ]
    
    hull1 = graham_scan(pts1)
    print("Пример 1: Выпуклая оболочка")
    print(f"Входные точки: {pts1}")
    print(f"Выпуклая оболочка: {hull1}")
    
    # Пример 2: Квадрат с центром
    pts2 = [
        (0, 0),
        (10, 0),
        (10, 10),
        (0, 10),
        (5, 5),  # центр, не в оболочке
    ]
    
    hull2 = graham_scan(pts2)
    print(f"\nПример 2: Квадрат с центром")
    print(f"Входные точки: {pts2}")
    print(f"Выпуклая оболочка: {hull2}")
    
    # Пример 3: Коллинеарные точки (в линию)
    pts3 = [(0, 0), (1, 1), (2, 2), (3, 3)]
    
    hull3 = graham_scan(pts3)
    print(f"\nПример 3: Коллинеарные точки")
    print(f"Входные точки: {pts3}")
    print(f"Выпуклая оболочка: {hull3}")
```

---

## 3.5 Оценка временной сложности алгоритма

### Временная сложность: O(n log n)

где n — количество точек.

### Обоснование:

1. **Поиск опорной точки p0 (S1-S3):** O(n)
   - Проходим по всем точкам один раз.

2. **Сортировка по полярному углу (S4):** O(n log n)
   - Это доминирующий шаг. Сортировка n − 1 точек занимает O(n log n).
   - Вычисление полярного угла для каждой точки: O(1).

3. **Основной цикл обхода точек (S5-S9):** O(n)
   - Хотя цикл имеет вложенный while, каждая точка добавляется и удаляется из стека hull ровно один раз.
   - Итого: O(n) операций.

4. **Итого:** O(n) + O(n log n) + O(n) = **O(n log n)**

### Пространственная сложность: O(n)

- Для хранения исходного списка точек: O(n)
- Для хранения отсортированного списка: O(n)
- Для хранения выпуклой оболочки: O(h), где h ≤ n — количество точек оболочки

### Примечание:
Алгоритм Грэхема — один из наиболее эффективных алгоритмов построения выпуклой оболочки. Существуют другие методы (например, Quick Hull), которые работают в среднем быстрее при случайном распределении точек, но Грэхем гарантирует O(n log n) в худшем случае.

---

# Алгоритм 4: Максимальный поток (Max Flow, Ford–Fulkerson / Edmonds–Karp)

## 4.1 Краткое описание области определения алгоритма

Задача о максимальном потоке в сети — одна из классических задач комбинаторной оптимизации. Её применяют для решения множества практических проблем.

**Определение:** Даны ориентированный граф (сеть), где каждому ребру приписана пропускная способность (capacity). Нужно найти максимальный поток от источника (source) к стоку (sink), такой что на каждом ребре поток не превышает его пропускную способность.

**Алгоритм Форда–Фалкерсона** — один из классических подходов. Его идея:
1. Найти дополняющий путь (путь, по которому ещё можно пропустить поток).
2. Пустить по этому пути максимальный возможный поток.
3. Повторять, пока дополняющие пути существуют.

### Применение на практике:
- Сетевые потоки: максимизация трафика в коммуникационных сетях;
- Логистика: оптимизация перевозок грузов;
- Биология: поиск путей в биологических сетях;
- Авиация: распределение самолётов на маршруты;
- Электроэнергетика: оптимизация передачи электроэнергии.

### Входные и выходные данные:
- **Вход:** Ориентированный граф (список рёбер с пропускными способностями), источник (s), сток (t).
- **Выход:** Максимальное значение потока от s к t, а также поток через каждое ребро (опционально).

---

## 4.2 Блок-схема алгоритма работы Ford–Fulkerson (Edmonds–Karp с BFS)

```
    ┌─────────────────────────────────┐
    │      НАЧАЛО                     │
    └────────────┬─────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  Получить граф G, источник s,   │
    │  сток t, пропускные способности │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │  S1: Инициализировать остаточный│
    │  граф (residual_graph) копией G  │
    │  max_flow ← 0                    │
    │  parent ← [ ]                    │
    └────────────┬──────────────────────┘
                 │
    ┌────────────▼──────────────────────┐
    │ S2: Пока существует путь из s   │
    │ в t в остаточном графе?         │
    │ (проверка через BFS)            │─── НЕТ ──┐
    └────┬───────────────────────────┘         │
         │ДА                                   │
    ┌────▼──────────────────────────────┐    │
    │ S3: Выполнить BFS из s в t в     │    │
    │ остаточном графе                 │    │
    │ Найти path и заполнить parent[]  │    │
    └────┬──────────────────────────────┘    │
         │                                   │
    ┌────▼──────────────────────────────┐   │
    │ S4: path_flow ← ∞                 │   │
    │ Пройти по пути от t к s,         │   │
    │ найти минимальную пропускную     │   │
    │ способность (узкое место)        │   │
    │ path_flow ← min(capacity на пути)│   │
    └────┬──────────────────────────────┘   │
         │                                  │
    ┌────▼──────────────────────────────┐  │
    │ S5: Обновить остаточный граф:    │  │
    │ Для каждого ребра на пути:       │  │
    │  - Уменьшить пропускную          │  │
    │    способность в прямом           │  │
    │    направлении на path_flow      │  │
    │  - Увеличить в обратном          │  │
    │    направлении на path_flow      │  │
    └────┬──────────────────────────────┘  │
         │                                 │
    ┌────▼──────────────────────────────┐ │
    │ S6: max_flow ← max_flow +        │ │
    │ path_flow                        │ │
    │ (вернуться к S2)                 │ │
    └────┬──────────────────────────────┘ │
         │                                │
         └────────────────────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │ S7: Вернуть max_flow             │
    └───────────────┬──────────────────┘
                    │
    ┌───────────────▼──────────────────┐
    │        КОНЕЦ                     │
    └────────────────────────────────────┘
```

---

## 4.3 Пошаговый анализ работы алгоритма

### Пример: найти максимальный поток в сети из 6 вершин

**Граф (начальные пропускные способности):**
```
    1 --16--> 2
   /|          |
16 | \10      12
  |  \        |
  |   X ----> 3 --20--> 5
  |  / 4      |
 13|/  \14    7
  |     \    |
  2 --13--> 4
              |
              4
              |
              v
```

**Вершины и рёбра:**

| Откуда | Куда | Пропускная способность |
|--------|------|------------------------|
| 0      | 1    | 16                     |
| 0      | 2    | 13                     |
| 1      | 2    | 10                     |
| 1      | 3    | 12                     |
| 2      | 1    | 4                      |
| 2      | 4    | 14                     |
| 3      | 2    | 9                      |
| 3      | 5    | 20                     |
| 4      | 3    | 7                      |
| 4      | 5    | 4                      |

Источник: 0, Сток: 5

### Итерации алгоритма

**Итерация 1:**
- Найденный путь: 0 → 1 → 3 → 5
- Узкое место (минимальная capacity): min(16, 12, 20) = 12
- max_flow = 0 + 12 = **12**
- Обновления остаточного графа (уменьшены значения в прямых ребрах, увеличены в обратных)

**Итерация 2:**
- Найденный путь: 0 → 2 → 4 → 5
- Узкое место: min(13, 14, 4) = 4
- max_flow = 12 + 4 = **16**

**Итерация 3:**
- Найденный путь: 0 → 1 → 2 → 4 → 3 → 5
- Узкое место: min(4, 10, 6, 7, 8) = 4
- max_flow = 16 + 4 = **20**

**Итерация 4:**
- Найденный путь: 0 → 1 → 3 (обратное ребро 3→2→4→5)
  - Более сложный путь с использованием обратных рёбер
- Узкое место: ...
- max_flow = **20 + ...**

В итоге, после всех итераций, **максимальный поток = 23**

---

## 4.4 Программный код алгоритма

```python
from collections import deque, defaultdict
from typing import Dict, List


class MaxFlow:
    """
    Класс для нахождения максимального потока в ориентированной сети
    методом Ford–Fulkerson (вариант Edmonds–Karp с использованием BFS).
    
    Атрибуты:
        V: количество вершин в графе
        graph: словарь словарей для хранения пропускных способностей
               graph[u][v] = capacity (по ребру u→v)
    """
    def __init__(self, vertices: int):
        """
        Инициализация графа с заданным количеством вершин.
        
        Args:
            vertices: количество вершин
        """
        self.V = vertices
        # graph[u][v] = пропускная способность ребра u→v
        self.graph: Dict[int, Dict[int, int]] = defaultdict(
            lambda: defaultdict(int)
        )

    def add_edge(self, u: int, v: int, capacity: int) -> None:
        """
        Добавить ориентированное ребро в граф.
        
        Args:
            u: исходная вершина
            v: целевая вершина
            capacity: пропускная способность
        """
        self.graph[u][v] += capacity  # поддержка множественных рёбер

    def _bfs(self, s: int, t: int, parent: List[int]) -> bool:
        """
        Поиск в ширину (BFS) по остаточному графу.
        Используется для проверки наличия пути от s к t.
        
        Args:
            s: исходная вершина (источник)
            t: целевая вершина (сток)
            parent: массив для хранения предков (для восстановления пути)
            
        Returns:
            True, если путь найден; иначе False
        """
        visited = [False] * self.V
        queue = deque([s])
        visited[s] = True
        parent[s] = -1

        # S3: BFS основной цикл
        while queue:
            u = queue.popleft()
            
            # Проходим по всем соседям u в остаточном графе
            for v, cap in self.graph[u].items():
                # Если вершина не посещена и есть остаточная пропускная способность
                if not visited[v] and cap > 0:
                    queue.append(v)
                    parent[v] = u
                    visited[v] = True
                    
                    # Если достигли стока, путь найден
                    if v == t:
                        return True
        
        return False

    def ford_fulkerson(self, s: int, t: int) -> int:
        """
        Найти максимальный поток от источника s к стоку t.
        
        Использует алгоритм Ford–Fulkerson с BFS (Edmonds–Karp).
        
        Args:
            s: источник
            t: сток
            
        Returns:
            Максимальное значение потока от s к t
            
        Временная сложность: O(V * E^2) в худшем случае
        """
        # S1: Инициализация
        parent = [-1] * self.V
        max_flow = 0

        # S2-S6: Основной цикл — пока существуют дополняющие пути
        while self._bfs(s, t, parent):
            
            # S4: Находим минимальную пропускную способность на пути
            # (узкое место)
            path_flow = float("inf")
            v = t
            while v != s:
                u = parent[v]
                path_flow = min(path_flow, self.graph[u][v])
                v = u

            # S5: Обновляем остаточные пропускные способности рёбер
            # (как в прямом, так и в обратном направлении)
            v = t
            while v != s:
                u = parent[v]
                # Уменьшаем пропускную способность в прямом направлении
                self.graph[u][v] -= path_flow
                # Увеличиваем в обратном направлении (для поддержки отмены)
                self.graph[v][u] += path_flow
                v = u

            # S6: Добавляем найденный поток к общему потоку
            max_flow += path_flow

        # S7: Возвращаем максимальный поток
        return int(max_flow)


# ===== ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ =====

if __name__ == "__main__":
    print("=" * 50)
    print("Пример: Максимальный поток в сети")
    print("=" * 50)
    
    # Создаём граф с 6 вершинами (0-5)
    g = MaxFlow(6)
    
    # Добавляем рёбра (u, v, capacity)
    g.add_edge(0, 1, 16)
    g.add_edge(0, 2, 13)
    g.add_edge(1, 2, 10)
    g.add_edge(1, 3, 12)
    g.add_edge(2, 1, 4)
    g.add_edge(2, 4, 14)
    g.add_edge(3, 2, 9)
    g.add_edge(3, 5, 20)
    g.add_edge(4, 3, 7)
    g.add_edge(4, 5, 4)

    print("\nГраф (пропускные способности):")
    print("0 → 1: 16")
    print("0 → 2: 13")
    print("1 → 2: 10")
    print("1 → 3: 12")
    print("2 → 1: 4")
    print("2 → 4: 14")
    print("3 → 2: 9")
    print("3 → 5: 20")
    print("4 → 3: 7")
    print("4 → 5: 4")
    
    source = 0
    sink = 5
    
    # Находим максимальный поток
    max_flow_value = g.ford_fulkerson(source, sink)
    
    print(f"\nИсточник (s): {source}")
    print(f"Сток (t): {sink}")
    print(f"\nМаксимальный поток = {max_flow_value}")
    
    # Пример 2: Простой граф
    print("\n" + "=" * 50)
    print("Пример 2: Простая сеть (3 вершины)")
    print("=" * 50)
    
    g2 = MaxFlow(3)
    g2.add_edge(0, 1, 1000)
    g2.add_edge(0, 2, 1000)
    g2.add_edge(1, 2, 1)
    
    print("\nГраф:")
    print("0 → 1: 1000")
    print("0 → 2: 1000")
    print("1 → 2: 1")
    
    max_flow_value2 = g2.ford_fulkerson(0, 2)
    print(f"\nМаксимальный поток от 0 к 2 = {max_flow_value2}")
```

---

## 4.5 Оценка временной сложности алгоритма

### Временная сложность: O(V · E²)

где V — количество вершин, E — количество рёбер.

Конкретнее для Edmonds–Karp (вариант с BFS): **O(V · E²)**

### Обоснование:

1. **BFS (S3):** O(V + E)
   - Посещение каждой вершины один раз: O(V)
   - Проверка каждого ребра один раз: O(E)

2. **Вычисление узкого места и обновление (S4-S5):** O(V)
   - Проход по пути: максимум V вершин
   - На каждом ребре пути одна операция обновления

3. **Количество итераций основного цикла (S2-S6):** O(V · E)
   - Каждый раз значение потока увеличивается минимум на 1
   - В худшем случае максимальный поток может быть O(V · E) (если все рёбра имеют пропускную способность 1 и т.д.)
   - Но более точно: максимум O(V · E) дополняющих путей

4. **Итого:** O(V · E) × O(V + E) ≈ **O(V · E²)** (так как E ≥ V - 1 в связной сети)

### Примечание:
Существуют более быстрые алгоритмы:
- **Dinic's algorithm:** O(V² · E)
- **Push–relabel algorithm:** O(V³) или O(V² · √E) с некоторыми оптимизациями

Однако Ford–Fulkerson с BFS остаётся простым и понятным вариантом с гарантированной полиномиальной сложностью.

### Пространственная сложность: O(V + E)

- Хранение графа: O(E)
- Структуры для BFS: O(V)
- Массив parent: O(V)

---

# Заключение

В данной лабораторной работе были изучены и реализованы четыре важных алгоритма из разных предметных областей:

1. **Автоматы и регулярные выражения (DFA/NFA)** — O(|s|) — используются в лексическом анализе и поиске по шаблону.

2. **Внешняя сортировка (External Merge Sort)** — O(n log n) — необходима для сортировки больших файлов, которые не помещаются в памяти.

3. **Выпуклая оболочка (Convex Hull)** — O(n log n) — применяется в вычислительной геометрии и обработке изображений.

4. **Максимальный поток (Ford–Fulkerson)** — O(V · E²) — решает задачи оптимизации сетевых потоков.

Каждый алгоритм имеет ясную теоретическую основу, эффективную реализацию на Python и широкое практическое применение.

---

**Дата сдачи:** 19 декабря 2025 г.
